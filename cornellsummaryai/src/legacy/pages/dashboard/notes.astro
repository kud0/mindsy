---
import Layout from "../../layouts/ModernDashboardLayout.astro";
import { NotesContent } from "../../components/dashboard/NotesContent";
import { requireAuth, createClient } from "../../lib/supabase-server";
import { getLangFromUrl } from "../../lib/i18n";

// Get user and check auth
const { user, response } = await requireAuth(Astro.cookies);
if (response) return response;

const supabase = createClient(Astro.cookies);

// Fetch user profile and data
const { data: profile } = await supabase
  .from('profiles')
  .select('*')
  .eq('id', user.id)
  .single();

// Fetch ALL user's study nodes
const { data: studyNodesData } = await supabase
  .from('study_nodes')
  .select('*')
  .eq('user_id', user.id)
  .order('sort_order')
  .order('name');

const studyNodes = (studyNodesData || []).map((node: any) => ({
  id: String(node.id),
  name: node.name,
  type: node.type,
  count: 0, // We'll count these after loading jobs
  parentId: node.parent_id ? String(node.parent_id) : undefined,
  children: [],
  isStudyNode: true
}));

// Build study node hierarchy
const nodeMap = new Map(studyNodes.map((n: any) => [String(n.id), n]));
const rootNodes: any[] = [];

studyNodes.forEach((node: any) => {
  if (node.parentId) {
    const parent = nodeMap.get(String(node.parentId));
    if (parent) {
      if (!parent.children) parent.children = [];
      parent.children.push(node);
    }
  } else {
    rootNodes.push(node);
  }
});

// Helper to build study path
function getStudyPath(nodeId: string): string {
  const path: string[] = [];
  let currentId = nodeId;
  
  while (currentId) {
    const node = nodeMap.get(currentId);
    if (node) {
      path.unshift(node.name);
      currentId = node.parentId;
    } else {
      break;
    }
  }
  
  return path.join(' / ');
}

// For backward compatibility, still support old folders if they exist
const folders = rootNodes; // Use study nodes as folders
const rootFolders = rootNodes; // Alias for compatibility

// Fetch ALL user's notes (jobs) with attachment counts - no filters
const { data: jobs } = await supabase
  .from('jobs')
  .select(`
    *,
    notes!left (
      attachment_count
    )
  `)
  .eq('user_id', user.id)
  .order('created_at', { ascending: false });

// Map jobs to notes format - now using study_node_id
const notes = (jobs || []).map((job: any) => {
  // Try study_node_id first, fallback to folder_id for backward compatibility
  const nodeId = job.study_node_id || job.folder_id;
  const node = nodeId ? nodeMap.get(String(nodeId)) : null;
  
  // Update node count
  if (node) {
    node.count++;
  }
  
  return {
    id: job.job_id || job.id,  // Use job_id if available, fallback to id
    title: job.lecture_title || 'Untitled',
    createdAt: job.created_at,
    status: job.status || 'completed',
    folder: node ? { 
      id: String(node.id), 
      name: node.name,
      path: getStudyPath(String(node.id)),
      type: node.type // Include type for icon display
    } : undefined,
    studyNodeId: job.study_node_id, // Keep study node reference
    duration: job.audio_duration ? `${Math.round(job.audio_duration / 60)}m` : undefined,
    attachmentCount: job.notes?.[0]?.attachment_count || 0, // Include attachment count from notes table
    hasOriginalDocument: job.txt_file_path && job.txt_file_path.includes('summaries/') // Document pipeline stores original in summaries/
  };
});

// Get usage data using the existing RPC function
const { data: usageData } = await supabase
  .rpc('get_current_usage', { p_user_id: user.id });

const usage = usageData?.[0];

// Use the minute-based data from the RPC function  
const minutesUsed = usage?.current_usage_minutes || 0;
const minutesLimit = usage?.monthly_limit_minutes || 180; // Default to 3 hours for free

// Determine user plan - check both tier and subscription_tier fields
const rawPlan = profile?.subscription_tier || profile?.tier || usage?.user_tier || 'free';
// Normalize to only free or student
const plan = rawPlan.toLowerCase() === 'student' ? 'student' : 'free';

const userData = {
  id: user.id,
  name: profile?.full_name || user.email?.split('@')[0] || 'User',
  email: user.email || '',
  avatar: profile?.avatar_url,
  plan: plan.toLowerCase(),
  minutesUsed,
  minutesLimit
};

// Check for note parameter in URL
const noteIdFromUrl = Astro.url.searchParams.get('note');

const lang = getLangFromUrl(Astro.url);

// Debug: Log the data we're passing
console.log('Passing to dashboard:', {
  notesCount: notes.length,
  foldersCount: rootFolders.length,
  userData
});
---

<Layout title="Notes" description="Manage and organize your notes" folders={folders}>
  <NotesContent 
    client:only="react"
    user={userData}
    initialNotes={notes}
    initialFolders={folders}
    noteIdFromUrl={noteIdFromUrl}
  />
</Layout>